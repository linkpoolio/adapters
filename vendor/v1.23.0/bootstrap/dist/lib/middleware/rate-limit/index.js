"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withRateLimit = exports.maxAgeFor = exports.makeId = exports.computeThroughput = exports.reducer = exports.actions = void 0;
const tslib_1 = require("tslib");
const util_1 = require("../../middleware/cache-key/util");
const actions_1 = require("./actions");
const metrics = tslib_1.__importStar(require("./metrics"));
const reducer_1 = require("./reducer");
exports.actions = tslib_1.__importStar(require("./actions"));
exports.reducer = tslib_1.__importStar(require("./reducer"));
/**
 * Calculates how much capacity a participant deserves based on its weight on the adapter
 * @param state Redux Heartbeats state
 * @param interval Time window size to get heartbeats
 * @param id Participant ID to get participants heartbeats
 */
const computeThroughput = (config, state, interval, id) => {
    // All observed in interval
    const totalThroughtput = reducer_1.selectTotalNumberOfHeartbeatsFor(state, interval);
    // All of type observed in interval
    const observedRequestsOfParticipant = reducer_1.selectParticiantsHeartbeatsFor(state, interval, id);
    const throughputOfParticipant = observedRequestsOfParticipant.length + 1;
    const costOfParticipant = getAverageCost(observedRequestsOfParticipant) || 1;
    // Compute max throughput by weight
    const weight = throughputOfParticipant / totalThroughtput;
    return maxThroughput(weight, costOfParticipant, config.totalCapacity);
};
exports.computeThroughput = computeThroughput;
const getAverageCost = (requests) => {
    if (!requests || requests.length === 0)
        return 0;
    return requests.reduce((totalCost, h) => totalCost + h.c, 0) / requests.length;
};
const maxThroughput = (weight, cost, totalCapacity) => {
    const maxAllowedCapacity = 0.9 * (totalCapacity / cost);
    return weight * maxAllowedCapacity;
};
/**
 * [LEGACY] Returns hash of the input request payload excluding some volatile paths
 *
 * @param request payload
 */
const makeId = (request) => util_1.hash(request, util_1.getHashOpts());
exports.makeId = makeId;
/**
 * Calculate maxAge to keep the item cached so we allow the specified throughput.
 *
 * @param throughput number of allowed requests in interval
 * @param interval time window in ms
 */
const maxAgeFor = (throughput, interval) => throughput <= 0 ? interval : Math.floor(interval / throughput);
exports.maxAgeFor = maxAgeFor;
const withRateLimit = (store) => async (execute, context) => async (input) => {
    const config = context.rateLimit ?? {};
    if (!config.enabled)
        return await execute(input, context);
    let state = store.getState();
    const { heartbeats } = state;
    const requestTypeId = input?.debug?.cacheKey ?? exports.makeId(input);
    const maxThroughput = exports.computeThroughput(config, heartbeats, reducer_1.IntervalNames.HOUR, requestTypeId);
    const maxAge = exports.maxAgeFor(maxThroughput, reducer_1.Intervals[reducer_1.IntervalNames.MINUTE]);
    const result = await execute({ ...input, rateLimitMaxAge: maxAge }, context);
    store.dispatch(actions_1.successfulResponseObserved(input, result));
    state = store.getState();
    const defaultLabels = {
        feed_id: input.metricsMeta?.feedId ?? 'N/A',
        participant_id: requestTypeId,
        experimental: 'true',
    };
    const cost = result.debug?.providerCost || 1;
    metrics.rateLimitCreditsSpentTotal.labels(defaultLabels).inc(isNaN(cost) ? 1 : cost);
    return result;
};
exports.withRateLimit = withRateLimit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL21pZGRsZXdhcmUvcmF0ZS1saW1pdC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsMERBQW1FO0FBQ25FLHVDQUFzRDtBQUV0RCwyREFBb0M7QUFDcEMsdUNBUWtCO0FBQ2xCLDZEQUFvQztBQUNwQyw2REFBb0M7QUFFcEM7Ozs7O0dBS0c7QUFDSSxNQUFNLGlCQUFpQixHQUFHLENBQy9CLE1BQWMsRUFDZCxLQUFpQixFQUNqQixRQUF1QixFQUN2QixFQUFVLEVBQ0YsRUFBRTtJQUNWLDJCQUEyQjtJQUMzQixNQUFNLGdCQUFnQixHQUFHLDBDQUFnQyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUMxRSxtQ0FBbUM7SUFDbkMsTUFBTSw2QkFBNkIsR0FBRyx3Q0FBOEIsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBQ3pGLE1BQU0sdUJBQXVCLEdBQUcsNkJBQTZCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQTtJQUN4RSxNQUFNLGlCQUFpQixHQUFHLGNBQWMsQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUM1RSxtQ0FBbUM7SUFDbkMsTUFBTSxNQUFNLEdBQUcsdUJBQXVCLEdBQUcsZ0JBQWdCLENBQUE7SUFFekQsT0FBTyxhQUFhLENBQUMsTUFBTSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQTtBQUN2RSxDQUFDLENBQUE7QUFoQlksUUFBQSxpQkFBaUIscUJBZ0I3QjtBQUVELE1BQU0sY0FBYyxHQUFHLENBQUMsUUFBcUIsRUFBVSxFQUFFO0lBQ3ZELElBQUksQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDO1FBQUUsT0FBTyxDQUFDLENBQUE7SUFDaEQsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxF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TWlkZGxld2FyZSB9IGZyb20gJ0BjaGFpbmxpbmsvdHlwZXMnXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHsgZ2V0SGFzaE9wdHMsIGhhc2ggfSBmcm9tICcuLi8uLi9taWRkbGV3YXJlL2NhY2hlLWtleS91dGlsJ1xuaW1wb3J0IHsgc3VjY2Vzc2Z1bFJlc3BvbnNlT2JzZXJ2ZWQgfSBmcm9tICcuL2FjdGlvbnMnXG5pbXBvcnQgeyBDb25maWcgfSBmcm9tICcuL2NvbmZpZydcbmltcG9ydCAqIGFzIG1ldHJpY3MgZnJvbSAnLi9tZXRyaWNzJ1xuaW1wb3J0IHtcbiAgSGVhcnRiZWF0LFxuICBIZWFydGJlYXRzLFxuICBJbnRlcnZhbE5hbWVzLFxuICBJbnRlcnZhbHMsXG4gIFJvb3RTdGF0ZSxcbiAgc2VsZWN0UGFydGljaWFudHNIZWFydGJlYXRzRm9yLFxuICBzZWxlY3RUb3RhbE51bWJlck9mSGVhcnRiZWF0c0Zvcixcbn0gZnJvbSAnLi9yZWR1Y2VyJ1xuZXhwb3J0ICogYXMgYWN0aW9ucyBmcm9tICcuL2FjdGlvbnMnXG5leHBvcnQgKiBhcyByZWR1Y2VyIGZyb20gJy4vcmVkdWNlcidcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGhvdyBtdWNoIGNhcGFjaXR5IGEgcGFydGljaXBhbnQgZGVzZXJ2ZXMgYmFzZWQgb24gaXRzIHdlaWdodCBvbiB0aGUgYWRhcHRlclxuICogQHBhcmFtIHN0YXRlIFJlZHV4IEhlYXJ0YmVhdHMgc3RhdGVcbiAqIEBwYXJhbSBpbnRlcnZhbCBUaW1lIHdpbmRvdyBzaXplIHRvIGdldCBoZWFydGJlYXRzXG4gKiBAcGFyYW0gaWQgUGFydGljaXBhbnQgSUQgdG8gZ2V0IHBhcnRpY2lwYW50cyBoZWFydGJlYXRzXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wdXRlVGhyb3VnaHB1dCA9IChcbiAgY29uZmlnOiBDb25maWcsXG4gIHN0YXRlOiBIZWFydGJlYXRzLFxuICBpbnRlcnZhbDogSW50ZXJ2YWxOYW1lcyxcbiAgaWQ6IHN0cmluZyxcbik6IG51bWJlciA9PiB7XG4gIC8vIEFsbCBvYnNlcnZlZCBpbiBpbnRlcnZhbFxuICBjb25zdCB0b3RhbFRocm91Z2h0cHV0ID0gc2VsZWN0VG90YWxOdW1iZXJPZkhlYXJ0YmVhdHNGb3Ioc3RhdGUsIGludGVydmFsKVxuICAvLyBBbGwgb2YgdHlwZSBvYnNlcnZlZCBpbiBpbnRlcnZhbFxuICBjb25zdCBvYnNlcnZlZFJlcXVlc3RzT2ZQYXJ0aWNpcGFudCA9IHNlbGVjdFBhcnRpY2lhbnRzSGVhcnRiZWF0c0ZvcihzdGF0ZSwgaW50ZXJ2YWwsIGlkKVxuICBjb25zdCB0aHJvdWdocHV0T2ZQYXJ0aWNpcGFudCA9IG9ic2VydmVkUmVxdWVzdHNPZlBhcnRpY2lwYW50Lmxlbmd0aCArIDFcbiAgY29uc3QgY29zdE9mUGFydGljaXBhbnQgPSBnZXRBdmVyYWdlQ29zdChvYnNlcnZlZFJlcXVlc3RzT2ZQYXJ0aWNpcGFudCkgfHwgMVxuICAvLyBDb21wdXRlIG1heCB0aHJvdWdocHV0IGJ5IHdlaWdodFxuICBjb25zdCB3ZWlnaHQgPSB0aHJvdWdocHV0T2ZQYXJ0aWNpcGFudCAvIHRvdGFsVGhyb3VnaHRwdXRcblxuICByZXR1cm4gbWF4VGhyb3VnaHB1dCh3ZWlnaHQsIGNvc3RPZlBhcnRpY2lwYW50LCBjb25maWcudG90YWxDYXBhY2l0eSlcbn1cblxuY29uc3QgZ2V0QXZlcmFnZUNvc3QgPSAocmVxdWVzdHM6IEhlYXJ0YmVhdFtdKTogbnVtYmVyID0+IHtcbiAgaWYgKCFyZXF1ZXN0cyB8fCByZXF1ZXN0cy5sZW5ndGggPT09IDApIHJldHVybiAwXG4gIHJldHVybiByZXF1ZXN0cy5yZWR1Y2UoKHRvdGFsQ29zdCwgaCkgPT4gdG90YWxDb3N0ICsgaC5jLCAwKSAvIHJlcXVlc3RzLmxlbmd0aFxufVxuXG5jb25zdCBtYXhUaHJvdWdocHV0ID0gKHdlaWdodDogbnVtYmVyLCBjb3N0OiBudW1iZXIsIHRvdGFsQ2FwYWNpdHk6IG51bWJlcik6IG51bWJlciA9PiB7XG4gIGNvbnN0IG1heEFsbG93ZWRDYXBhY2l0eSA9IDAuOSAqICh0b3RhbENhcGFjaXR5IC8gY29zdClcbiAgcmV0dXJuIHdlaWdodCAqIG1heEFsbG93ZWRDYXBhY2l0eVxufVxuXG4vKipcbiAqIFtMRUdBQ1ldIFJldHVybnMgaGFzaCBvZiB0aGUgaW5wdXQgcmVxdWVzdCBwYXlsb2FkIGV4Y2x1ZGluZyBzb21lIHZvbGF0aWxlIHBhdGhzXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgcGF5bG9hZFxuICovXG5leHBvcnQgY29uc3QgbWFrZUlkID0gKHJlcXVlc3Q6IEFkYXB0ZXJSZXF1ZXN0KTogc3RyaW5nID0+IGhhc2gocmVxdWVzdCwgZ2V0SGFzaE9wdHMoKSlcblxuLyoqXG4gKiBDYWxjdWxhdGUgbWF4QWdlIHRvIGtlZXAgdGhlIGl0ZW0gY2FjaGVkIHNvIHdlIGFsbG93IHRoZSBzcGVjaWZpZWQgdGhyb3VnaHB1dC5cbiAqXG4gKiBAcGFyYW0gdGhyb3VnaHB1dCBudW1iZXIgb2YgYWxsb3dlZCByZXF1ZXN0cyBpbiBpbnRlcnZhbFxuICogQHBhcmFtIGludGVydmFsIHRpbWUgd2luZG93IGluIG1zXG4gKi9cbmV4cG9ydCBjb25zdCBtYXhBZ2VGb3IgPSAodGhyb3VnaHB1dDogbnVtYmVyLCBpbnRlcnZhbDogbnVtYmVyKTogbnVtYmVyID0+XG4gIHRocm91Z2hwdXQgPD0gMCA/IGludGVydmFsIDogTWF0aC5mbG9vcihpbnRlcnZhbCAvIHRocm91Z2hwdXQpXG5cbmV4cG9ydCBjb25zdCB3aXRoUmF0ZUxpbWl0ID1cbiAgKHN0b3JlOiBTdG9yZTxSb290U3RhdGU+KTogTWlkZGxld2FyZSA9PlxuICBhc3luYyAoZXhlY3V0ZSwgY29udGV4dCkgPT5cbiAgYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgY29uc3QgY29uZmlnID0gY29udGV4dC5yYXRlTGltaXQgPz8ge31cbiAgICBpZiAoIWNvbmZpZy5lbmFibGVkKSByZXR1cm4gYXdhaXQgZXhlY3V0ZShpbnB1dCwgY29udGV4dClcbiAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpXG4gICAgY29uc3QgeyBoZWFydGJlYXRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHJlcXVlc3RUeXBlSWQgPSBpbnB1dD8uZGVidWc/LmNhY2hlS2V5ID8/IG1ha2VJZChpbnB1dClcbiAgICBjb25zdCBtYXhUaHJvdWdocHV0ID0gY29tcHV0ZVRocm91Z2hwdXQoY29uZmlnLCBoZWFydGJlYXRzLCBJbnRlcnZhbE5hbWVzLkhPVVIsIHJlcXVlc3RUeXBlSWQpXG4gICAgY29uc3QgbWF4QWdlID0gbWF4QWdlRm9yKG1heFRocm91Z2hwdXQsIEludGVydmFsc1tJbnRlcnZhbE5hbWVzLk1JTlVURV0pXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZSh7IC4uLmlucHV0LCByYXRlTGltaXRNYXhBZ2U6IG1heEFnZSB9LCBjb250ZXh0KVxuXG4gICAgc3RvcmUuZGlzcGF0Y2goc3VjY2Vzc2Z1bFJlc3BvbnNlT2JzZXJ2ZWQoaW5wdXQsIHJlc3VsdCkpXG4gICAgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpXG5cbiAgICBjb25zdCBkZWZhdWx0TGFiZWxzID0ge1xuICAgICAgZmVlZF9pZDogaW5wdXQubWV0cmljc01ldGE/LmZlZWRJZCA/PyAnTi9BJyxcbiAgICAgIHBhcnRpY2lwYW50X2lkOiByZXF1ZXN0VHlwZUlkLFxuICAgICAgZXhwZXJpbWVudGFsOiAndHJ1ZScsXG4gICAgfVxuICAgIGNvbnN0IGNvc3QgPSByZXN1bHQuZGVidWc/LnByb3ZpZGVyQ29zdCB8fCAxXG4gICAgbWV0cmljcy5yYXRlTGltaXRDcmVkaXRzU3BlbnRUb3RhbC5sYWJlbHMoZGVmYXVsdExhYmVscykuaW5jKGlzTmFOKGNvc3QpID8gMSA6IGNvc3QpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiJdfQ==