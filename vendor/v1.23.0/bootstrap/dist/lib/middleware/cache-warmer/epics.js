"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.epicMiddleware = exports.rootEpic = exports.warmupUnsubscriber = exports.warmupRequestHandler = exports.warmupSubscriber = exports.executeHandler = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const redux_observable_1 = require("redux-observable");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const actions_1 = require("./actions");
const config_1 = require("./config");
const util_1 = require("./util");
const ttl_1 = require("../cache/ttl");
const metrics = tslib_1.__importStar(require("./metrics"));
const util_2 = require("../../metrics/util");
const executeHandler = (action$, state$) => {
    const warmupExecute$ = action$.pipe(operators_1.filter(actions_1.warmupExecute.match));
    const [batchExecute$, execute$] = rxjs_1.partition(warmupExecute$, (val) => !!val.payload.result?.debug?.batchablePropertyPath);
    const subscribeBatch$ = batchExecute$.pipe(operators_1.withLatestFrom(state$), operators_1.mergeMap(([{ payload }, state]) => {
        const actionsToDispatch = [];
        const batchablePropertyPath = payload.result?.debug?.batchablePropertyPath;
        // We want the key to be consistent. So we omit batchable paths.
        // Otherwise it would change on every new child
        const batchWarmerSubscriptionKey = payload.debug?.batchCacheKey ??
            util_1.getSubscriptionKey(lodash_1.omit(payload, batchablePropertyPath?.map(({ name }) => `data.${name}`)));
        const existingBatchWarmer = state.cacheWarmer.subscriptions[batchWarmerSubscriptionKey];
        // Start placeholder subscriptions for children
        const childLastSeenById = {};
        // If result was from a batch request
        if (payload.result?.data?.results) {
            const members = [];
            for (const [childKey, request] of Object.values(payload.result.data.results)) {
                const warmupSubscribedPayloadChild = {
                    ...payload,
                    ...request,
                    parent: batchWarmerSubscriptionKey,
                    batchablePropertyPath,
                    key: childKey,
                };
                childLastSeenById[childKey] = Date.now();
                members.push(warmupSubscribedPayloadChild);
            }
            actionsToDispatch.push(actions_1.warmupSubscribedMultiple({ members }));
        }
        else {
            const warmupSubscribedPayloadChild = {
                ...payload,
                parent: batchWarmerSubscriptionKey,
                batchablePropertyPath,
            };
            const childKey = payload.debug?.cacheKey ?? util_1.getSubscriptionKey(warmupSubscribedPayloadChild);
            childLastSeenById[childKey] = Date.now();
            actionsToDispatch.push(actions_1.warmupSubscribed(warmupSubscribedPayloadChild));
        }
        // If batch warmer already exists join it by adding childLastSeenById to request data
        if (existingBatchWarmer && batchablePropertyPath) {
            actionsToDispatch.push(actions_1.warmupJoinGroup({
                parent: batchWarmerSubscriptionKey,
                childLastSeenById: childLastSeenById,
                batchablePropertyPath,
            }));
        }
        // If batch warmer does not exist, start it
        else {
            // If incoming batchable request parameters aren't an array, transform into one
            let batchWarmerData = {
                ...payload.data,
                resultPath: undefined,
            };
            for (const { name } of batchablePropertyPath || []) {
                if (!Array.isArray(batchWarmerData[name]))
                    batchWarmerData = {
                        ...batchWarmerData,
                        [name]: [batchWarmerData[name]],
                    };
            }
            actionsToDispatch.push(actions_1.warmupSubscribed({
                ...payload,
                data: batchWarmerData,
                key: batchWarmerSubscriptionKey,
                childLastSeenById,
                batchablePropertyPath,
            }));
        }
        return rxjs_1.from(actionsToDispatch);
    }));
    const subscribeIndividual$ = execute$.pipe(operators_1.map(({ payload }) => actions_1.warmupSubscribed(payload)));
    return rxjs_1.merge(subscribeBatch$, subscribeIndividual$);
};
exports.executeHandler = executeHandler;
const warmupSubscriber = (action$, state$, { config }) => action$.pipe(operators_1.filter(actions_1.warmupSubscribed.match), operators_1.map(({ payload }) => ({
    payload,
    key: payload.key || payload.debug?.cacheKey || util_1.getSubscriptionKey(payload),
})), operators_1.withLatestFrom(state$), 
// check if the subscription already exists, then noop
operators_1.filter(([{ payload, key }, state]) => {
    // if a child, register, but don't warm
    if (payload.parent) {
        return false;
    }
    // if subscription does not exist, then continue
    // this check doesnt work because state is already set!
    return !state.cacheWarmer.subscriptions[key]?.isDuplicate;
}), operators_1.tap(([{ payload }]) => {
    const labels = {
        isBatched: String(!!payload.childLastSeenById),
    };
    metrics.cache_warmer_count.labels(labels).inc();
}), 
// on a subscribe action being dispatched, spin up a long lived interval if one doesnt exist yet
operators_1.mergeMap(([{ payload, key }]) => {
    // Interval should be set to the warmup interval if configured,
    // otherwise use the TTL from the request.
    const interval = Math.max(ttl_1.getMaxAgeOverride(payload) || config.warmupInterval || ttl_1.getTTL(payload), config_1.MINIMUM_WARMUP_INTERVAL);
    const pollInterval = interval > config_1.WARMUP_POLL_OFFSET * 2 ? interval - config_1.WARMUP_POLL_OFFSET : interval;
    return rxjs_1.timer(pollInterval, pollInterval).pipe(operators_1.mapTo(actions_1.warmupRequested({ key })), operators_1.takeUntil(action$.pipe(operators_1.filter(actions_1.warmupShutdown.match))), 
    // unsubscribe our warmup algo when a matching unsubscribe comes in
    operators_1.takeUntil(action$.pipe(operators_1.filter(actions_1.warmupUnsubscribed.match || actions_1.warmupStopped.match), operators_1.filter((a) => {
        return (('key' in a.payload && a.payload.key === key) ||
            ('keys' in a.payload && a.payload.keys.includes(key)));
    }), operators_1.withLatestFrom(state$), operators_1.tap(([{ payload }]) => {
        const labels = {
            isBatched: String(payload.isBatched),
        };
        metrics.cache_warmer_count.labels(labels).dec();
    }))));
}));
exports.warmupSubscriber = warmupSubscriber;
/**
 * Handle warmup response request events
 */
const warmupRequestHandler = (action$, state$) => action$.pipe(
// this pipeline will execute when we have a request to warm up an adapter
operators_1.filter(actions_1.warmupRequested.match), 
// fetch our required state to make a request to warm up an adapter
operators_1.withLatestFrom(state$), operators_1.map(([action, state]) => {
    return {
        requestData: state.cacheWarmer.subscriptions[action.payload.key],
        key: action.payload.key,
        subscriptions: state.cacheWarmer.subscriptions,
    };
}), operators_1.filter(({ requestData }) => !!requestData), 
// make the request
operators_1.mergeMap(({ requestData, key }) => rxjs_1.from(requestData.batchablePropertyPath
    ? (async () => {
        const batches = util_1.splitIntoBatches(requestData);
        const requests = [];
        for (const batch of Object.values(batches)) {
            const data = {
                ...requestData.origin,
                ...batch,
            };
            requests.push(requestData.executeFn({
                id: requestData.childLastSeenById ? config_1.WARMUP_BATCH_REQUEST_ID : config_1.WARMUP_REQUEST_ID,
                data,
                debug: { warmer: true },
            }));
        }
        const responses = await Promise.all(requests);
        let result = null;
        for (const resp of responses) {
            result = util_1.concatenateBatchResults(result, resp);
        }
        return result;
    })()
    : requestData.executeFn({
        id: requestData.childLastSeenById ? config_1.WARMUP_BATCH_REQUEST_ID : config_1.WARMUP_REQUEST_ID,
        data: { ...requestData.origin },
        debug: { warmer: true },
    })).pipe(operators_1.mapTo(actions_1.warmupFulfilled({ key })), operators_1.catchError((error) => rxjs_1.of(actions_1.warmupFailed({
    feedLabel: util_2.getFeedId({
        id: requestData.childLastSeenById ? config_1.WARMUP_BATCH_REQUEST_ID : config_1.WARMUP_REQUEST_ID,
        data: requestData?.origin,
    }),
    error: error,
    key,
}))))));
exports.warmupRequestHandler = warmupRequestHandler;
// we can combine this into one of the above epics if we have performance issues later on
const warmupUnsubscriber = (action$, state$, { config }) => {
    const unsubscribeOnFailure$ = action$.pipe(operators_1.filter(actions_1.warmupFailed.match), operators_1.withLatestFrom(state$), operators_1.filter(([{ payload }, state]) => (state.cacheWarmer.warmups[payload.key]?.errorCount ?? 0 >= config.unhealthyThreshold) &&
        config.unhealthyThreshold !== -1), operators_1.map(([{ payload }, state]) => {
        const isBatched = !!state.cacheWarmer.subscriptions[payload.key]?.childLastSeenById;
        return actions_1.warmupUnsubscribed({
            key: payload.key,
            isBatched,
            reason: `Errored: ${payload.error.message}`,
        });
    }));
    // emits whenever a subscription event comes in,
    // used as a helper stream for the timeout limit stream
    const keyedSubscription$ = action$.pipe(operators_1.filter(actions_1.warmupSubscribed.match), operators_1.map(({ payload }) => ({
        payload,
        key: payload.debug?.cacheKey || util_1.getSubscriptionKey(payload),
    })));
    const unsubscribeOnTimeout$ = keyedSubscription$.pipe(
    // when a subscription comes in
    operators_1.withLatestFrom(state$), operators_1.mergeMap(([{ key }, state]) => {
        // we look for matching subscriptions of the same type
        // which deactivates the current timer
        const reset$ = keyedSubscription$.pipe(operators_1.filter(({ key: keyB }) => key === keyB), operators_1.take(1), operators_1.mapTo(actions_1.warmupSubscriptionTimeoutReset({ key })));
        const isBatched = !!state.cacheWarmer.subscriptions[key]?.childLastSeenById;
        // start the current unsubscription timer
        const timeout$ = rxjs_1.of(actions_1.warmupUnsubscribed({ key, isBatched, reason: 'Timeout' })).pipe(operators_1.delay(config.subscriptionTTL), operators_1.takeUntil(action$.pipe(operators_1.filter(actions_1.warmupShutdown.match))));
        // if a re-subscription comes in before timeout emits, then we emit nothing
        // else we unsubscribe from the current subscription
        return rxjs_1.race(reset$, timeout$);
    }));
    const stopOnBatch$ = keyedSubscription$.pipe(
    // when a subscription comes in, if it has children
    operators_1.filter(({ payload }) => !!payload?.childLastSeenById), operators_1.mergeMap(({ payload }) => [
        actions_1.warmupStopped({
            keys: Object.keys(payload?.childLastSeenById || {}),
            isBatched: !!payload?.childLastSeenById,
        }),
    ]));
    const unsubscribeOnBatchEmpty$ = action$.pipe(operators_1.filter(actions_1.warmupLeaveGroup.match), operators_1.withLatestFrom(state$), operators_1.filter(([{ payload }, state]) => {
        for (const { name } of payload.batchablePropertyPath) {
            if (state.cacheWarmer.subscriptions[payload.parent].origin[name].length === 0)
                return true;
        }
        return false;
    }), operators_1.map(([{ payload }]) => actions_1.warmupUnsubscribed({
        key: payload.parent,
        isBatched: true,
        reason: 'Empty Batch Warmer request data',
    })));
    return rxjs_1.merge(unsubscribeOnFailure$, unsubscribeOnTimeout$, stopOnBatch$, unsubscribeOnBatchEmpty$);
};
exports.warmupUnsubscriber = warmupUnsubscriber;
exports.rootEpic = redux_observable_1.combineEpics(exports.executeHandler, exports.warmupSubscriber, exports.warmupUnsubscriber, exports.warmupRequestHandler);
exports.epicMiddleware = redux_observable_1.createEpicMiddleware({
    dependencies: { config: config_1.get() },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXBpY3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL21pZGRsZXdhcmUvY2FjaGUtd2FybWVyL2VwaWNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxtQ0FBNkI7QUFFN0IsdURBQTJFO0FBQzNFLCtCQUE4RDtBQUM5RCw4Q0FXdUI7QUFFdkIsdUNBZWtCO0FBQ2xCLHFDQU9pQjtBQUNqQixpQ0FBc0Y7QUFDdEYsc0NBQXdEO0FBQ3hELDJEQUFvQztBQUNwQyw2Q0FBOEM7QUFPdkMsTUFBTSxjQUFjLEdBQTRELENBQ3JGLE9BQU8sRUFDUCxNQUFNLEVBQ04sRUFBRTtJQUNGLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQU0sQ0FBQyx1QkFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUE7SUFDaEUsTUFBTSxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsR0FBRyxnQkFBUyxDQUN6QyxjQUFjLEVBQ2QsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUscUJBQXFCLENBQzVELENBQUE7SUFFRCxNQUFNLGVBQWUsR0FBRyxhQUFhLENBQUMsSUFBSSxDQUN4QywwQkFBYyxDQUFDLE1BQU0sQ0FBQyxFQUN0QixvQkFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDaEMsTUFBTSxpQkFBaUIsR0FBZ0IsRUFBRSxDQUFBO1FBRXpDLE1BQU0scUJBQXFCLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUscUJBQXFCLENBQUE7UUFFMUUsZ0VBQWdFO1FBQ2hFLCtDQUErQztRQUMvQyxNQUFNLDBCQUEwQixHQUM5QixPQUFPLENBQUMsS0FBSyxFQUFFLGFBQWE7WUFDNUIseUJBQWtCLENBQ2hCLGFBQUksQ0FDRixPQUFPLEVB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RUFDdEIsa0JBQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFO1FBQzlCLEtBQUssTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtZQUNwRCxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUM7Z0JBQUUsT0FBTyxJQUFJLENBQUE7U0FDM0Y7UUFDRCxPQUFPLEtBQUssQ0FBQTtJQUNkLENBQUMsQ0FBQyxFQUNGLGVBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDcEIsNEJBQWtCLENBQUM7UUFDakIsR0FBRyxFQUFFLE9BQU8sQ0FBQyxNQUFNO1FBQ25CLFNBQVMsRUFBRSxJQUFJO1FBQ2YsTUFBTSxFQUFFLGlDQUFpQztLQUMxQyxDQUFDLENBQ0gsQ0FDRixDQUFBO0lBRUQsT0FBTyxZQUFLLENBQUMscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUsWUFBWSxFQUFFLHdCQUF3QixDQUFDLENBQUE7QUFDcEcsQ0FBQyxDQUFBO0FBeEZZLFFBQUEsa0JBQWtCLHNCQXdGOUI7QUFFWSxRQUFBLFFBQVEsR0FBRywrQkFBWSxDQUNsQyxzQkFBYyxFQUNkLHdCQUFnQixFQUNoQiwwQkFBa0IsRUFDbEIsNEJBQW9CLENBQ3JCLENBQUE7QUFFWSxRQUFBLGNBQWMsR0FBRyx1Q0FBb0IsQ0FBa0M7SUFDbEYsWUFBWSxFQUFFLEVBQUUsTUFBTSxFQUFFLFlBQUcsRUFBRSxFQUFFO0NBQ2hDLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkYXB0ZXJSZXF1ZXN0IH0gZnJvbSAnQGNoYWlubGluay90eXBlcydcbmltcG9ydCB7IG9taXQgfSBmcm9tICdsb2Rhc2gnXG5pbXBvcnQgeyBBbnlBY3Rpb24gfSBmcm9tICdyZWR1eCdcbmltcG9ydCB7IGNvbWJpbmVFcGljcywgY3JlYXRlRXBpY01pZGRsZXdhcmUsIEVwaWMgfSBmcm9tICdyZWR1eC1vYnNlcnZhYmxlJ1xuaW1wb3J0IHsgZnJvbSwgbWVyZ2UsIG9mLCBwYXJ0aXRpb24sIHJhY2UsIHRpbWVyIH0gZnJvbSAncnhqcydcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGRlbGF5LFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgbWFwVG8sXG4gIG1lcmdlTWFwLFxuICB0YXAsXG4gIHRha2UsXG4gIHRha2VVbnRpbCxcbiAgd2l0aExhdGVzdEZyb20sXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJ1xuaW1wb3J0IHsgUm9vdFN0YXRlIH0gZnJvbSAnLi4vLi4vLi4nXG5pbXBvcnQge1xuICB3YXJtdXBFeGVjdXRlLFxuICB3YXJtdXBGYWlsZWQsXG4gIHdhcm11cEZ1bGZpbGxlZCxcbiAgd2FybXVwSm9pbkdyb3VwLFxuICB3YXJtdXBMZWF2ZUdyb3VwLFxuICB3YXJtdXBSZXF1ZXN0ZWQsXG4gIHdhcm11cFNodXRkb3duLFxuICB3YXJtdXBTdG9wcGVkLFxuICBXYXJtdXBTdG9wcGVkUGF5bG9hZCxcbiAgd2FybXVwU3Vic2NyaWJlZCxcbiAgd2FybXVwU3Vic2NyaWJlZE11bHRpcGxlLFxuICB3YXJtdXBTdWJzY3JpcHRpb25UaW1lb3V0UmVzZXQsXG4gIHdhcm11cFVuc3Vic2NyaWJlZCxcbiAgV2FybXVwVW5zdWJzY3JpYmVkUGF5bG9hZCxcbn0gZnJvbSAnLi9hY3Rpb25zJ1xuaW1wb3J0IHtcbiAgQ29uZmlnLFxuICBnZXQsXG4gIFdBUk1VUF9SRVFVRVNUX0lELFxuICBXQVJNVVBfQkFUQ0hfUkVRVUVTVF9JRCxcbiAgTUlOSU1VTV9XQVJNVVBfSU5URVJWQUwsXG4gIFdBUk1VUF9QT0xMX09GRlNFVCxcbn0gZnJvbSAnLi9jb25maWcnXG5pbXBvcnQgeyBjb25jYXRlbmF0ZUJhdGNoUmVzdWx0cywgZ2V0U3Vic2NyaXB0aW9uS2V5LCBzcGxpdEludG9CYXRjaGVzIH0gZnJvbSAnLi91dGlsJ1xuaW1wb3J0IHsgZ2V0VFRMLCBnZXRNYXhBZ2VPdmVycmlkZSB9IGZyb20gJy4uL2NhY2hlL3R0bCdcbmltcG9ydCAqIGFzIG1ldHJpY3MgZnJvbSAnLi9tZXRyaWNzJ1xuaW1wb3J0IHsgZ2V0RmVlZElkIH0gZnJvbSAnLi4vLi4vbWV0cmljcy91dGlsJ1xuaW1wb3J0IHsgUGF5bG9hZEFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXBpY0RlcGVuZGVuY2llcyB7XG4gIGNvbmZpZzogQ29uZmlnXG59XG5cbmV4cG9ydCBjb25zdCBleGVjdXRlSGFuZGxlcjogRXBpYzxBbnlBY3Rpb24sIEFueUFjdGlvbiwgUm9vdFN0YXRlLCBFcGljRGVwZW5kZW5jaWVzPiA9IChcbiAgYWN0aW9uJCxcbiAgc3RhdGUkLFxuKSA9PiB7XG4gIGNvbnN0IHdhcm11cEV4ZWN1dGUkID0gYWN0aW9uJC5waXBlKGZpbHRlcih3YXJtdXBFeGVjdXRlLm1hdGNoKSlcbiAgY29uc3QgW2JhdGNoRXhlY3V0ZSQsIGV4ZWN1dGUkXSA9IHBhcnRpdGlvbihcbiAgICB3YXJtdXBFeGVjdXRlJCxcbiAgICAodmFsKSA9PiAhIXZhbC5wYXlsb2FkLnJlc3VsdD8uZGVidWc/LmJhdGNoYWJsZVByb3BlcnR5UGF0aCxcbiAgKVxuXG4gIGNvbnN0IHN1YnNjcmliZUJhdGNoJCA9IGJhdGNoRXhlY3V0ZSQucGlwZShcbiAgICB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLFxuICAgIG1lcmdlTWFwKChbeyBwYXlsb2FkIH0sIHN0YXRlXSkgPT4ge1xuICAgICAgY29uc3QgYWN0aW9uc1RvRGlzcGF0Y2g6IEFueUFjdGlvbltdID0gW11cblxuICAgICAgY29uc3QgYmF0Y2hhYmxlUHJvcGVydHlQYXRoID0gcGF5bG9hZC5yZXN1bHQ/LmRlYnVnPy5iYXRjaGFibGVQcm9wZXJ0eVBhdGhcblxuICAgICAgLy8gV2Ugd2FudCB0aGUga2V5IHRvIGJlIGNvbnNpc3RlbnQuIFNvIHdlIG9taXQgYmF0Y2hhYmxlIHBhdGhzLlxuICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGNoYW5nZSBvbiBldmVyeSBuZXcgY2hpbGRcbiAgICAgIGNvbnN0IGJhdGNoV2FybWVyU3Vic2NyaXB0aW9uS2V5ID1cbiAgICAgICAgcGF5bG9hZC5kZWJ1Zz8uYmF0Y2hDYWNoZUtleSA/P1xuICAgICAgICBnZXRTdWJzY3JpcHRpb25LZXkoXG4gICAgICAgICAgb21pdChcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICBiYXRjaGFibGVQcm9wZXJ0eVBhdGg/Lm1hcCgoeyBuYW1lIH0pID0+IGBkYXRhLiR7bmFtZX1gKSxcbiAgICAgICAgICApLFxuICAgICAgICApXG5cbiAgICAgIGNvbnN0IGV4aXN0aW5nQmF0Y2hXYXJtZXIgPSBzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zW2JhdGNoV2FybWVyU3Vic2NyaXB0aW9uS2V5XVxuXG4gICAgICAvLyBTdGFydCBwbGFjZWhvbGRlciBzdWJzY3JpcHRpb25zIGZvciBjaGlsZHJlblxuICAgICAgY29uc3QgY2hpbGRMYXN0U2VlbkJ5SWQ6IHsgW2NoaWxkS2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG4gICAgICAvLyBJZiByZXN1bHQgd2FzIGZyb20gYSBiYXRjaCByZXF1ZXN0XG4gICAgICBpZiAocGF5bG9hZC5yZXN1bHQ/LmRhdGE/LnJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkS2V5LCByZXF1ZXN0XSBvZiBPYmplY3QudmFsdWVzPFtzdHJpbmcsIEFkYXB0ZXJSZXF1ZXN0LCBudW1iZXJdPihcbiAgICAgICAgICBwYXlsb2FkLnJlc3VsdC5kYXRhLnJlc3VsdHMsXG4gICAgICAgICkpIHtcbiAgICAgICAgICBjb25zdCB3YXJtdXBTdWJzY3JpYmVkUGF5bG9hZENoaWxkID0ge1xuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICBwYXJlbnQ6IGJhdGNoV2FybWVyU3Vic2NyaXB0aW9uS2V5LFxuICAgICAgICAgICAgYmF0Y2hhYmxlUHJvcGVydHlQYXRoLFxuICAgICAgICAgICAga2V5OiBjaGlsZEtleSxcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRMYXN0U2VlbkJ5SWRbY2hpbGRLZXldID0gRGF0ZS5ub3coKVxuICAgICAgICAgIG1lbWJlcnMucHVzaCh3YXJtdXBTdWJzY3JpYmVkUGF5bG9hZENoaWxkKVxuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnNUb0Rpc3BhdGNoLnB1c2god2FybXVwU3Vic2NyaWJlZE11bHRpcGxlKHsgbWVtYmVycyB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdhcm11cFN1YnNjcmliZWRQYXlsb2FkQ2hpbGQgPSB7XG4gICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICBwYXJlbnQ6IGJhdGNoV2FybWVyU3Vic2NyaXB0aW9uS2V5LFxuICAgICAgICAgIGJhdGNoYWJsZVByb3BlcnR5UGF0aCxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBheWxvYWQuZGVidWc/LmNhY2hlS2V5ID8/IGdldFN1YnNjcmlwdGlvbktleSh3YXJtdXBTdWJzY3JpYmVkUGF5bG9hZENoaWxkKVxuICAgICAgICBjaGlsZExhc3RTZWVuQnlJZFtjaGlsZEtleV0gPSBEYXRlLm5vdygpXG4gICAgICAgIGFjdGlvbnNUb0Rpc3BhdGNoLnB1c2god2FybXVwU3Vic2NyaWJlZCh3YXJtdXBTdWJzY3JpYmVkUGF5bG9hZENoaWxkKSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYmF0Y2ggd2FybWVyIGFscmVhZHkgZXhpc3RzIGpvaW4gaXQgYnkgYWRkaW5nIGNoaWxkTGFzdFNlZW5CeUlkIHRvIHJlcXVlc3QgZGF0YVxuICAgICAgaWYgKGV4aXN0aW5nQmF0Y2hXYXJtZXIgJiYgYmF0Y2hhYmxlUHJvcGVydHlQYXRoKSB7XG4gICAgICAgIGFjdGlvbnNUb0Rpc3BhdGNoLnB1c2goXG4gICAgICAgICAgd2FybXVwSm9pbkdyb3VwKHtcbiAgICAgICAgICAgIHBhcmVudDogYmF0Y2hXYXJtZXJTdWJzY3JpcHRpb25LZXksXG4gICAgICAgICAgICBjaGlsZExhc3RTZWVuQnlJZDogY2hpbGRMYXN0U2VlbkJ5SWQsXG4gICAgICAgICAgICBiYXRjaGFibGVQcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgfSksXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIC8vIElmIGJhdGNoIHdhcm1lciBkb2VzIG5vdCBleGlzdCwgc3RhcnQgaXRcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiBpbmNvbWluZyBiYXRjaGFibGUgcmVxdWVzdCBwYXJhbWV0ZXJzIGFyZW4ndCBhbiBhcnJheSwgdHJhbnNmb3JtIGludG8gb25lXG4gICAgICAgIGxldCBiYXRjaFdhcm1lckRhdGEgPSB7XG4gICAgICAgICAgLi4ucGF5bG9hZC5kYXRhLFxuICAgICAgICAgIHJlc3VsdFBhdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSB9IG9mIGJhdGNoYWJsZVByb3BlcnR5UGF0aCB8fCBbXSkge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXRjaFdhcm1lckRhdGFbbmFtZV0pKVxuICAgICAgICAgICAgYmF0Y2hXYXJtZXJEYXRhID0ge1xuICAgICAgICAgICAgICAuLi5iYXRjaFdhcm1lckRhdGEsXG4gICAgICAgICAgICAgIFtuYW1lXTogW2JhdGNoV2FybWVyRGF0YVtuYW1lXV0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhY3Rpb25zVG9EaXNwYXRjaC5wdXNoKFxuICAgICAgICAgIHdhcm11cFN1YnNjcmliZWQoe1xuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIGRhdGE6IGJhdGNoV2FybWVyRGF0YSxcbiAgICAgICAgICAgIGtleTogYmF0Y2hXYXJtZXJTdWJzY3JpcHRpb25LZXksXG4gICAgICAgICAgICBjaGlsZExhc3RTZWVuQnlJZCxcbiAgICAgICAgICAgIGJhdGNoYWJsZVByb3BlcnR5UGF0aCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnJvbShhY3Rpb25zVG9EaXNwYXRjaClcbiAgICB9KSxcbiAgKVxuXG4gIGNvbnN0IHN1YnNjcmliZUluZGl2aWR1YWwkID0gZXhlY3V0ZSQucGlwZShtYXAoKHsgcGF5bG9hZCB9KSA9PiB3YXJtdXBTdWJzY3JpYmVkKHBheWxvYWQpKSlcblxuICByZXR1cm4gbWVyZ2Uoc3Vic2NyaWJlQmF0Y2gkLCBzdWJzY3JpYmVJbmRpdmlkdWFsJClcbn1cblxuZXhwb3J0IGNvbnN0IHdhcm11cFN1YnNjcmliZXI6IEVwaWM8QW55QWN0aW9uLCBBbnlBY3Rpb24sIGFueSwgRXBpY0RlcGVuZGVuY2llcz4gPSAoXG4gIGFjdGlvbiQsXG4gIHN0YXRlJCxcbiAgeyBjb25maWcgfSxcbikgPT5cbiAgYWN0aW9uJC5waXBlKFxuICAgIGZpbHRlcih3YXJtdXBTdWJzY3JpYmVkLm1hdGNoKSxcbiAgICBtYXAoKHsgcGF5bG9hZCB9KSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIGtleTogcGF5bG9hZC5rZXkgfHwgcGF5bG9hZC5kZWJ1Zz8uY2FjaGVLZXkgfHwgZ2V0U3Vic2NyaXB0aW9uS2V5KHBheWxvYWQpLFxuICAgIH0pKSxcbiAgICB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLFxuICAgIC8vIGNoZWNrIGlmIHRoZSBzdWJzY3JpcHRpb24gYWxyZWFkeSBleGlzdHMsIHRoZW4gbm9vcFxuICAgIGZpbHRlcigoW3sgcGF5bG9hZCwga2V5IH0sIHN0YXRlXSkgPT4ge1xuICAgICAgLy8gaWYgYSBjaGlsZCwgcmVnaXN0ZXIsIGJ1dCBkb24ndCB3YXJtXG4gICAgICBpZiAocGF5bG9hZC5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvLyBpZiBzdWJzY3JpcHRpb24gZG9lcyBub3QgZXhpc3QsIHRoZW4gY29udGludWVcbiAgICAgIC8vIHRoaXMgY2hlY2sgZG9lc250IHdvcmsgYmVjYXVzZSBzdGF0ZSBpcyBhbHJlYWR5IHNldCFcbiAgICAgIHJldHVybiAhc3RhdGUuY2FjaGVXYXJtZXIuc3Vic2NyaXB0aW9uc1trZXldPy5pc0R1cGxpY2F0ZVxuICAgIH0pLFxuICAgIHRhcCgoW3sgcGF5bG9hZCB9XSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWxzID0ge1xuICAgICAgICBpc0JhdGNoZWQ6IFN0cmluZyghIXBheWxvYWQuY2hpbGRMYXN0U2VlbkJ5SWQpLFxuICAgICAgfVxuICAgICAgbWV0cmljcy5jYWNoZV93YXJtZXJfY291bnQubGFiZWxzKGxhYmVscykuaW5jKClcbiAgICB9KSxcbiAgICAvLyBvbiBhIHN1YnNjcmliZSBhY3Rpb24gYmVpbmcgZGlzcGF0Y2hlZCwgc3BpbiB1cCBhIGxvbmcgbGl2ZWQgaW50ZXJ2YWwgaWYgb25lIGRvZXNudCBleGlzdCB5ZXRcbiAgICBtZXJnZU1hcCgoW3sgcGF5bG9hZCwga2V5IH1dKSA9PiB7XG4gICAgICAvLyBJbnRlcnZhbCBzaG91bGQgYmUgc2V0IHRvIHRoZSB3YXJtdXAgaW50ZXJ2YWwgaWYgY29uZmlndXJlZCxcbiAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIFRUTCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBNYXRoLm1heChcbiAgICAgICAgZ2V0TWF4QWdlT3ZlcnJpZGUocGF5bG9hZCkgfHwgY29uZmlnLndhcm11cEludGVydmFsIHx8IGdldFRUTChwYXlsb2FkKSxcbiAgICAgICAgTUlOSU1VTV9XQVJNVVBfSU5URVJWQUwsXG4gICAgICApXG4gICAgICBjb25zdCBwb2xsSW50ZXJ2YWwgPVxuICAgICAgICBpbnRlcnZhbCA+IFdBUk1VUF9QT0xMX09GRlNFVCAqIDIgPyBpbnRlcnZhbCAtIFdBUk1VUF9QT0xMX09GRlNFVCA6IGludGVydmFsXG4gICAgICByZXR1cm4gdGltZXIocG9sbEludGVydmFsLCBwb2xsSW50ZXJ2YWwpLnBpcGUoXG4gICAgICAgIG1hcFRvKHdhcm11cFJlcXVlc3RlZCh7IGtleSB9KSksXG4gICAgICAgIHRha2VVbnRpbChhY3Rpb24kLnBpcGUoZmlsdGVyKHdhcm11cFNodXRkb3duLm1hdGNoKSkpLFxuICAgICAgICAvLyB1bnN1YnNjcmliZSBvdXIgd2FybXVwIGFsZ28gd2hlbiBhIG1hdGNoaW5nIHVuc3Vic2NyaWJlIGNvbWVzIGluXG4gICAgICAgIHRha2VVbnRpbChcbiAgICAgICAgICBhY3Rpb24kLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIod2FybXVwVW5zdWJzY3JpYmVkLm1hdGNoIHx8IHdhcm11cFN0b3BwZWQubWF0Y2gpLFxuICAgICAgICAgICAgZmlsdGVyKChhOiBQYXlsb2FkQWN0aW9uPFdhcm11cFVuc3Vic2NyaWJlZFBheWxvYWQgfCBXYXJtdXBTdG9wcGVkUGF5bG9hZD4pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoJ2tleScgaW4gYS5wYXlsb2FkICYmIGEucGF5bG9hZC5rZXkgPT09IGtleSkgfHxcbiAgICAgICAgICAgICAgICAoJ2tleXMnIGluIGEucGF5bG9hZCAmJiBhLnBheWxvYWQua2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCksXG4gICAgICAgICAgICB0YXAoKFt7IHBheWxvYWQgfV0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFiZWxzID0ge1xuICAgICAgICAgICAgICAgIGlzQmF0Y2hlZDogU3RyaW5nKHBheWxvYWQuaXNCYXRjaGVkKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZXRyaWNzLmNhY2hlX3dhcm1lcl9jb3VudC5sYWJlbHMobGFiZWxzKS5kZWMoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKSxcbiAgICAgICAgKSxcbiAgICAgIClcbiAgICB9KSxcbiAgKVxuXG4vKipcbiAqIEhhbmRsZSB3YXJtdXAgcmVzcG9uc2UgcmVxdWVzdCBldmVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm11cFJlcXVlc3RIYW5kbGVyOiBFcGljPEFueUFjdGlvbiwgQW55QWN0aW9uLCBhbnk+ID0gKGFjdGlvbiQsIHN0YXRlJCkgPT5cbiAgYWN0aW9uJC5waXBlKFxuICAgIC8vIHRoaXMgcGlwZWxpbmUgd2lsbCBleGVjdXRlIHdoZW4gd2UgaGF2ZSBhIHJlcXVlc3QgdG8gd2FybSB1cCBhbiBhZGFwdGVyXG4gICAgZmlsdGVyKHdhcm11cFJlcXVlc3RlZC5tYXRjaCksXG4gICAgLy8gZmV0Y2ggb3VyIHJlcXVpcmVkIHN0YXRlIHRvIG1ha2UgYSByZXF1ZXN0IHRvIHdhcm0gdXAgYW4gYWRhcHRlclxuICAgIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCksXG4gICAgbWFwKChbYWN0aW9uLCBzdGF0ZV0pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3REYXRhOiBzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zW2FjdGlvbi5wYXlsb2FkLmtleV0sXG4gICAgICAgIGtleTogYWN0aW9uLnBheWxvYWQua2V5LFxuICAgICAgICBzdWJzY3JpcHRpb25zOiBzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zLFxuICAgICAgfVxuICAgIH0pLFxuICAgIGZpbHRlcigoeyByZXF1ZXN0RGF0YSB9KSA9PiAhIXJlcXVlc3REYXRhKSxcbiAgICAvLyBtYWtlIHRoZSByZXF1ZXN0XG4gICAgbWVyZ2VNYXAoKHsgcmVxdWVzdERhdGEsIGtleSB9KSA9PlxuICAgICAgZnJvbShcbiAgICAgICAgcmVxdWVzdERhdGEuYmF0Y2hhYmxlUHJvcGVydHlQYXRoXG4gICAgICAgICAgPyAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gc3BsaXRJbnRvQmF0Y2hlcyhyZXF1ZXN0RGF0YSlcbiAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIE9iamVjdC52YWx1ZXMoYmF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgLi4ucmVxdWVzdERhdGEub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgLi4uYmF0Y2gsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3RzLnB1c2goXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YS5leGVjdXRlRm4oe1xuICAgICAgICAgICAgICAgICAgICBpZDogcmVxdWVzdERhdGEuY2hpbGRMYXN0U2VlbkJ5SWQgPyBXQVJNVVBfQkFUQ0hfUkVRVUVTVF9JRCA6IFdBUk1VUF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogeyB3YXJtZXI6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cylcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGxcbiAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNwIG9mIHJlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbmNhdGVuYXRlQmF0Y2hSZXN1bHRzKHJlc3VsdCwgcmVzcClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgICAgOiByZXF1ZXN0RGF0YS5leGVjdXRlRm4oe1xuICAgICAgICAgICAgICBpZDogcmVxdWVzdERhdGEuY2hpbGRMYXN0U2VlbkJ5SWQgPyBXQVJNVVBfQkFUQ0hfUkVRVUVTVF9JRCA6IFdBUk1VUF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICBkYXRhOiB7IC4uLnJlcXVlc3REYXRhLm9yaWdpbiB9LFxuICAgICAgICAgICAgICBkZWJ1ZzogeyB3YXJtZXI6IHRydWUgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgKS5waXBlKFxuICAgICAgICBtYXBUbyh3YXJtdXBGdWxmaWxsZWQoeyBrZXkgfSkpLFxuICAgICAgICBjYXRjaEVycm9yKChlcnJvcjogdW5rbm93bikgPT5cbiAgICAgICAgICBvZihcbiAgICAgICAgICAgIHdhcm11cEZhaWxlZCh7XG4gICAgICAgICAgICAgIGZlZWRMYWJlbDogZ2V0RmVlZElkKHtcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdERhdGEuY2hpbGRMYXN0U2VlbkJ5SWQgPyBXQVJNVVBfQkFUQ0hfUkVRVUVTVF9JRCA6IFdBUk1VUF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3REYXRhPy5vcmlnaW4sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICksXG4gICAgICAgICksXG4gICAgICApLFxuICAgICksXG4gIClcblxuLy8gd2UgY2FuIGNvbWJpbmUgdGhpcyBpbnRvIG9uZSBvZiB0aGUgYWJvdmUgZXBpY3MgaWYgd2UgaGF2ZSBwZXJmb3JtYW5jZSBpc3N1ZXMgbGF0ZXIgb25cbmV4cG9ydCBjb25zdCB3YXJtdXBVbnN1YnNjcmliZXI6IEVwaWM8QW55QWN0aW9uLCBBbnlBY3Rpb24sIGFueSwgRXBpY0RlcGVuZGVuY2llcz4gPSAoXG4gIGFjdGlvbiQsXG4gIHN0YXRlJCxcbiAgeyBjb25maWcgfSxcbikgPT4ge1xuICBjb25zdCB1bnN1YnNjcmliZU9uRmFpbHVyZSQgPSBhY3Rpb24kLnBpcGUoXG4gICAgZmlsdGVyKHdhcm11cEZhaWxlZC5tYXRjaCksXG4gICAgd2l0aExhdGVzdEZyb20oc3RhdGUkKSxcbiAgICBmaWx0ZXIoXG4gICAgICAoW3sgcGF5bG9hZCB9LCBzdGF0ZV0pID0+XG4gICAgICAgIChzdGF0ZS5jYWNoZVdhcm1lci53YXJtdXBzW3BheWxvYWQua2V5XT8uZXJyb3JDb3VudCA/PyAwID49IGNvbmZpZy51bmhlYWx0aHlUaHJlc2hvbGQpICYmXG4gICAgICAgIGNvbmZpZy51bmhlYWx0aHlUaHJlc2hvbGQgIT09IC0xLFxuICAgICksXG4gICAgbWFwKChbeyBwYXlsb2FkIH0sIHN0YXRlXSkgPT4ge1xuICAgICAgY29uc3QgaXNCYXRjaGVkID0gISFzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zW3BheWxvYWQua2V5XT8uY2hpbGRMYXN0U2VlbkJ5SWRcbiAgICAgIHJldHVybiB3YXJtdXBVbnN1YnNjcmliZWQoe1xuICAgICAgICBrZXk6IHBheWxvYWQua2V5LFxuICAgICAgICBpc0JhdGNoZWQsXG4gICAgICAgIHJlYXNvbjogYEVycm9yZWQ6ICR7cGF5bG9hZC5lcnJvci5tZXNzYWdlfWAsXG4gICAgICB9KVxuICAgIH0pLFxuICApXG5cbiAgLy8gZW1pdHMgd2hlbmV2ZXIgYSBzdWJzY3JpcHRpb24gZXZlbnQgY29tZXMgaW4sXG4gIC8vIHVzZWQgYXMgYSBoZWxwZXIgc3RyZWFtIGZvciB0aGUgdGltZW91dCBsaW1pdCBzdHJlYW1cbiAgY29uc3Qga2V5ZWRTdWJzY3JpcHRpb24kID0gYWN0aW9uJC5waXBlKFxuICAgIGZpbHRlcih3YXJtdXBTdWJzY3JpYmVkLm1hdGNoKSxcbiAgICBtYXAoKHsgcGF5bG9hZCB9KSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIGtleTogcGF5bG9hZC5kZWJ1Zz8uY2FjaGVLZXkgfHwgZ2V0U3Vic2NyaXB0aW9uS2V5KHBheWxvYWQpLFxuICAgIH0pKSxcbiAgKVxuXG4gIGNvbnN0IHVuc3Vic2NyaWJlT25UaW1lb3V0JCA9IGtleWVkU3Vic2NyaXB0aW9uJC5waXBlKFxuICAgIC8vIHdoZW4gYSBzdWJzY3JpcHRpb24gY29tZXMgaW5cbiAgICB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLFxuICAgIG1lcmdlTWFwKChbeyBrZXkgfSwgc3RhdGVdKSA9PiB7XG4gICAgICAvLyB3ZSBsb29rIGZvciBtYXRjaGluZyBzdWJzY3JpcHRpb25zIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC8vIHdoaWNoIGRlYWN0aXZhdGVzIHRoZSBjdXJyZW50IHRpbWVyXG4gICAgICBjb25zdCByZXNldCQgPSBrZXllZFN1YnNjcmlwdGlvbiQucGlwZShcbiAgICAgICAgZmlsdGVyKCh7IGtleToga2V5QiB9KSA9PiBrZXkgPT09IGtleUIpLFxuICAgICAgICB0YWtlKDEpLFxuICAgICAgICBtYXBUbyh3YXJtdXBTdWJzY3JpcHRpb25UaW1lb3V0UmVzZXQoeyBrZXkgfSkpLFxuICAgICAgKVxuICAgICAgY29uc3QgaXNCYXRjaGVkID0gISFzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zW2tleV0/LmNoaWxkTGFzdFNlZW5CeUlkXG5cbiAgICAgIC8vIHN0YXJ0IHRoZSBjdXJyZW50IHVuc3Vic2NyaXB0aW9uIHRpbWVyXG4gICAgICBjb25zdCB0aW1lb3V0JCA9IG9mKHdhcm11cFVuc3Vic2NyaWJlZCh7IGtleSwgaXNCYXRjaGVkLCByZWFzb246ICdUaW1lb3V0JyB9KSkucGlwZShcbiAgICAgICAgZGVsYXkoY29uZmlnLnN1YnNjcmlwdGlvblRUTCksXG4gICAgICAgIHRha2VVbnRpbChhY3Rpb24kLnBpcGUoZmlsdGVyKHdhcm11cFNodXRkb3duLm1hdGNoKSkpLFxuICAgICAgKVxuXG4gICAgICAvLyBpZiBhIHJlLXN1YnNjcmlwdGlvbiBjb21lcyBpbiBiZWZvcmUgdGltZW91dCBlbWl0cywgdGhlbiB3ZSBlbWl0IG5vdGhpbmdcbiAgICAgIC8vIGVsc2Ugd2UgdW5zdWJzY3JpYmUgZnJvbSB0aGUgY3VycmVudCBzdWJzY3JpcHRpb25cbiAgICAgIHJldHVybiByYWNlKHJlc2V0JCwgdGltZW91dCQpXG4gICAgfSksXG4gIClcblxuICBjb25zdCBzdG9wT25CYXRjaCQgPSBrZXllZFN1YnNjcmlwdGlvbiQucGlwZShcbiAgICAvLyB3aGVuIGEgc3Vic2NyaXB0aW9uIGNvbWVzIGluLCBpZiBpdCBoYXMgY2hpbGRyZW5cbiAgICBmaWx0ZXIoKHsgcGF5bG9hZCB9KSA9PiAhIXBheWxvYWQ/LmNoaWxkTGFzdFNlZW5CeUlkKSxcbiAgICBtZXJnZU1hcCgoeyBwYXlsb2FkIH0pID0+IFtcbiAgICAgIHdhcm11cFN0b3BwZWQoe1xuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyhwYXlsb2FkPy5jaGlsZExhc3RTZWVuQnlJZCB8fCB7fSksXG4gICAgICAgIGlzQmF0Y2hlZDogISFwYXlsb2FkPy5jaGlsZExhc3RTZWVuQnlJZCxcbiAgICAgIH0pLFxuICAgIF0pLFxuICApXG5cbiAgY29uc3QgdW5zdWJzY3JpYmVPbkJhdGNoRW1wdHkkID0gYWN0aW9uJC5waXBlKFxuICAgIGZpbHRlcih3YXJtdXBMZWF2ZUdyb3VwLm1hdGNoKSxcbiAgICB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLFxuICAgIGZpbHRlcigoW3sgcGF5bG9hZCB9LCBzdGF0ZV0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgeyBuYW1lIH0gb2YgcGF5bG9hZC5iYXRjaGFibGVQcm9wZXJ0eVBhdGgpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNhY2hlV2FybWVyLnN1YnNjcmlwdGlvbnNbcGF5bG9hZC5wYXJlbnRdLm9yaWdpbltuYW1lXS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KSxcbiAgICBtYXAoKFt7IHBheWxvYWQgfV0pID0+XG4gICAgICB3YXJtdXBVbnN1YnNjcmliZWQoe1xuICAgICAgICBrZXk6IHBheWxvYWQucGFyZW50LFxuICAgICAgICBpc0JhdGNoZWQ6IHRydWUsXG4gICAgICAgIHJlYXNvbjogJ0VtcHR5IEJhdGNoIFdhcm1lciByZXF1ZXN0IGRhdGEnLFxuICAgICAgfSksXG4gICAgKSxcbiAgKVxuXG4gIHJldHVybiBtZXJnZSh1bnN1YnNjcmliZU9uRmFpbHVyZSQsIHVuc3Vic2NyaWJlT25UaW1lb3V0JCwgc3RvcE9uQmF0Y2gkLCB1bnN1YnNjcmliZU9uQmF0Y2hFbXB0eSQpXG59XG5cbmV4cG9ydCBjb25zdCByb290RXBpYyA9IGNvbWJpbmVFcGljcyhcbiAgZXhlY3V0ZUhhbmRsZXIsXG4gIHdhcm11cFN1YnNjcmliZXIsXG4gIHdhcm11cFVuc3Vic2NyaWJlcixcbiAgd2FybXVwUmVxdWVzdEhhbmRsZXIsXG4pXG5cbmV4cG9ydCBjb25zdCBlcGljTWlkZGxld2FyZSA9IGNyZWF0ZUVwaWNNaWRkbGV3YXJlPGFueSwgYW55LCBhbnksIEVwaWNEZXBlbmRlbmNpZXM+KHtcbiAgZGVwZW5kZW5jaWVzOiB7IGNvbmZpZzogZ2V0KCkgfSxcbn0pXG4iXX0=